*------------------------------------------------------------*
* Training Log
Date:                May 06, 2020
Time:                18:32:09
*------------------------------------------------------------*
14714  proc freq data=EMWS5.TextParsing_VariableSet noprint;
14715  table ROLE*LEVEL/out=WORK.TextParsingMETA;
14716  run;

NOTE: There were 1 observations read from the data set EMWS5.TEXTPARSING_VARIABLESET.
NOTE: The data set WORK.TEXTPARSINGMETA has 1 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.07 seconds
      cpu time            0.01 seconds
      

14717  proc print data=WORK.TextParsingMETA label noobs;
14718  var ROLE LEVEL COUNT;
14719  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14720  title9 ' ';
14721  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14722  run;

NOTE: There were 1 observations read from the data set WORK.TEXTPARSINGMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

14723  title10;

14724  %let EMEXCEPTIONSTRING=;
15056  *------------------------------------------------------------*;
15057  * TextParsing: Generation of macros and macro variables;
15058  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15059  *------------------------------------------------------------*;

15060  %let EMEXCEPTIONSTRING=;
15061  *------------------------------------------------------------*;
15062  * TRAIN: TextParsing;
15063  *------------------------------------------------------------*;
15064  %let EM_ACTION = TRAIN;
15065  %let syscc = 0;
15066  %macro main();
15067    %if %upcase(&EM_ACTION) eq CREATE %then %do;
15068      filename temp catalog 'sashelp.emtxtext.parse_create.source';
15069      %include temp;
15070      %create();
15071    %end;
15072    %if %upcase(&EM_ACTION) eq TRAIN %then %do;
15073      filename temp catalog 'sashelp.emtxtext.parse_train.source';
15074      %include temp;
15075      %train();
15076    %end;
15077    %if %upcase(&EM_ACTION) eq REPORT %then %do;
15078      filename temp catalog 'sashelp.emtxtext.parse_report.source';
15079      %include temp;
15080      %report();
15081    %end;
15082    %if %upcase(&EM_ACTION) eq SCORE %then %do;
15083      filename temp catalog 'sashelp.emtxtext.parse_score.source';
15084      %include temp;
15085      %score();
15086    %end;
15087      %if %upcase(&EM_ACTION) eq OPENTABLE1 %then %do;
15088         filename temp catalog 'sashelp.emtxtext.parse_actions.source';
15089         %include temp;
15090         filename temp;
15091         %openTable1;
15092     %end;
15093  %mend main;
15094  
15095  %main();
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_TRAIN.SOURCE.
15096 +%macro train();
15097 +   %global EM_SASMSG;
15098 +   %global sysdocparse;
15099 +   %global syshptmine;
15100 +   %global default_entity;
15101 +   %let EM_SASMSG=TMINE;
15102 +   %let sysdocparse = ;
15103 +   %let syshptmine = ;
15104 +   %let last_parse_node= ;
15106 +   /* Make sure there are no prior text parsing nodes in diagram */
15107 +   %if %sysfunc(exist(&EM_IMPORT_DATA_EMINFO)) %then %do;
15108 +      proc sql noprint;
15109 +      select data into :last_parse_node from &EM_IMPORT_DATA_EMINFO
15110 +         where key="LastTextParsing";
15111 +      quit;
15112 +      %if &last_parse_node ne %then %do;
15113 +         %let EMEXCEPTIONSTRING = EMTOOL.PRIORPARSINGNODE;
15114 +         %goto end_parse_train;
15115 +         %end;
15117 +      %end;
15120 +   /* make sure datasets are inited*/
15121 +    filename temp catalog 'sashelp.emtxtext.parse_actions.source';
15122 +    %include temp;
15123 +    %openTable1();
15125 +   /* check language setinit at runtime */
15126 +   filename temp catalog "sashelp.emtxtext.getlanguages.source";
15127 +   %include temp;
15128 +   %let found_language = ;
15129 +   proc sql noprint;
15130 +      select language into :found_language
15131 +      from work.tm_languages
15132 +      where upcase("&EM_PROPERTY_LANGUAGE") eq upcase(language);
15133 +   quit;
15134 +   %if &found_language eq %then %do;
15135 +      * error if language setinit expired ;
15136 +      /* %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE; */
15137 +      %let EMEXCEPTIONSTRING = EMTOOL.NOLANGLICENSE, %upcase(&EM_PROPERTY_LANGUAGE);
15138 +      %goto end_parse_train;
15139 +   %end;
15141 +   /* There must be a training or raw data set passed in */
15142 +    %if &em_import_data= %then %do;
15143 +      %let EMEXCEPTIONSTRING = EMTOOL.NOTRAINDS;
15144 +      %goto end_parse_train;
15145 +   %end;
15148 +   /* load tgparse macro */
15149 +   filename temp catalog "sashelp.emtxtext.tm_parse.source";
15150 +   %include temp;
15152 +   /* load multiword write to xml macro */
15153 +   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
15154 +   %include temp;
15156 +   /* retrieve the output datasets so we can write to them */
15157 +   %em_getname(key=terms, type=data);
15158 +   %em_getname(key=tmout, type=data);
15159 +   %em_getname(key=tmoutpos, type=data);
15160 +   %em_getname(key=tmconfig, type=data);
15161 +   %em_getname(key=synonymDS, type=data);
15162 +   %em_getname(key=multiDS, type=data);
15163 +   %em_getname(key=stopList, type=data);
15164 +   %em_getname(key=startList, type=data);
15166 +   %em_getname(key=multiword, type=file, extension=txt);
15168 +   /* variables for choosing the parsing column */
15169 +   %let tm_parsevar = ;
15170 +   %let tm_urivar = ;
15171 +   %let tm_filteredvar = ;
15172 +   %let tm_displayVar = ;
15174 +   /* crawl through the metadata to set some property defaults */
15175 +   data _null_;
15176 +      length parsevar urivar filteredvar $32;
15177 +      retain max_len 0;
15178 +      retain parsevar '';
15179 +      retain urivar '';
15180 +      retain filteredvar '';
15182 +      set &em_data_variableset end=eof;
15184 +      if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
15185 +         parsevar = name;
15186 +         max_len = length;
15187 +      end;
15188 +      if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
15189 +      if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
15191 +      if eof then do;
15192 +         call symput('tm_parsevar', parsevar);
15193 +         call symput('tm_urivar', urivar);
15194 +         call symput('tm_filteredvar', filteredvar);
15195 +      end;
15196 +   run;
15199 +   %if %trim(%left(&tm_filteredvar)) ne %then %do;
15200 +      %let tm_displayVar = &tm_parseVar;
15201 +      %let tm_parsevar = &tm_filteredvar;
15202 +   %end;
15204 +   %em_propertychange(NAME=parseVar, VALUE=&tm_parsevar);
15206 +   %if %trim(%left(&tm_parsevar)) eq %then %do;
15207 +      /* error if no parsevar is found */
15208 +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSEVAR;
15209 +      %goto end_parse_train;
15210 +   %end;
15211 +   %else %do;
15212 +      /* identify which variable we are parsing */
15213 +      %put &em_codebar;
15214 +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.PARSEVAR_NOTE, NOQUOTE, &tm_parsevar));
15215 +      %put &errormsg;
15216 +      %put &em_codebar;
15217 +   %end;
15219 +   /* *** synonym data set changes *** */
15220 +   /* modify the synonymDS to a format that docparse can take (term, termrole, parent, parentrole) */
15221 +   %let category_exists = 0;
15222 +   %let termrole_exists = 0;
15223 +   %let parentrole_exists = 0;
15224 +   %let synonym_warning = ;
15225 +   data _null_;
15226 +      dsid=open("&EM_USER_SYNONYMDS");
15227 +      check=varnum(dsid,'category');
15228 +      if check ne 0 then call symput('category_exists', '1');
15229 +      check=varnum(dsid,'termrole');
15230 +      if check ne 0 then call symput('termrole_exists', '1');
15231 +      check=varnum(dsid,'parentrole');
15232 +      if check ne 0 then call symput('parentrole_exists', '1');
15233 +   run;
15235 +   proc sql noprint;
15236 +      create table work.internal_synds as
15237 +         select term, parent,
15238 +            %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then %do;
15239 +            /* termrole exists and parentrole exists, so just use them */
15240 +               termrole, parentrole
15241 +            %end;
15242 +            %else %if &termrole_exists ne 0 and &parentrole_exists eq 0 %then %do;
15243 +            /* no parentrole or category, so create a termrole as parentrole */
15244 +               %let synonym_warning = 1 ;
15245 +               termrole,
15246 +               termrole as parentrole
15247 +            %end;
15248 +            %else %if &termrole_exists eq 0 and &parentrole_exists ne 0 %then %do;
15249 +            /* no termrole or category, so create a parentrole as termrole*/
15250 +               %let synonym_warning = 1 ;
15251 +               parentrole as termrole,
15252 +               parentrole
15253 +            %end;
15254 +            %else %if &termrole_exists eq 0 and &parentrole_exists eq 0 and &category_exists eq 0 %then %do;
15255 +             /* no termrole, parentrole, and category, so create a blank termrole and a blank parentrole*/
15256 +               "" as termrole,
15257 +               "" as parentrole
15258 +            %end;
15259 +            %else %if &category_exists ne 0 %then %do;
15260 +            /* we're missing both termrole or parentrole, but we have category, so just use that for termrole and parentrole */
15261 +               category as termrole,
15262 +               category as parentrole
15263 +            %end;
15264 +         from &EM_USER_SYNONYMDS;
15265 +   quit;
15267 +   /* reset parentrole_exists and termrole_exists */
15268 +   %let parentrole_exists = 1;
15269 +   %let termrole_exists = 1;
15272 +    %let entities='PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE',
15273 +                 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS',
15274 +                 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD';
15276 +    data work.internal_synds;
15277 +        set work.internal_synds;
15278 +        %if &termrole_exists %then %do;
15279 +            if KUPCASE(termrole) in (&entities ) then
15280 +                termrole=KUPCASE(termrole);
15281 +        %end;
15282 +        %if &parentrole_exists %then %do;
15283 +            if KUPCASE(parentrole) in (&entities) then
15284 +                parentrole=KUPCASE(parentrole);
15285 +        %end;
15286 +    run;
15288 +   %let EM_USER_SYNONYMDS = work.internal_synds;
15289 +   %if &synonym_warning ne %then %do;
15290 +      %put &em_codebar;
15291 +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.SYN_CHANGE_WARN, NOQUOTE));
15292 +      %put &errormsg;
15293 +      %put &em_codebar;
15294 +   %end;
15296 +   /* Remove duplicate keys from input tables */
15297 +    proc sort data=work.internal_synds nodupkey;
15298 +        by term parent %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then termrole parentrole;
15299 +        %else category; ;
15300 +    run;
15302 +   proc sql noprint;
15303 +       select count(*) into :stoplist_count
15304 +       from &em_user_stoplist;
15305 +       select count(*) into :startlist_count
15306 +       from &em_user_startlist;
15307 +       create view _trainview as select * from &em_import_data;
15308 +    quit;
15310 +    %if &stoplist_count ne 0 %then %do;
15311 +        %let role_exists = 0;
15312 +        data _null_;
15313 +          dsid=open("&em_user_stoplist");
15314 +          check=varnum(dsid,'role');
15315 +          if check ne 0 then call symput('role_exists', '1');
15316 +        run;
15317 +        proc sort data=&em_user_stoplist nodupkey;
15318 +            by term %if &role_exists ne 0 %then role;;
15319 +        run;
15320 +    %end;
15321 +    %else %if &startlist_count ne 0 %then %do;
15322 +        proc sort data=&em_user_startlist nodupkey;
15323 +            by term role;
15324 +        run;
15325 +    %end;
15329 +    /* Filter out unwanted languages */
15330 +    %let filt=;
15331 +    %if %symexist(EM_PROPERTY_FILTERLANG) %then %if &EM_PROPERTY_FILTERLANG ne %then %do;
15332 +        %let filt=%qkupcase(&EM_PROPERTY_FILTERLANG);
15333 +        %let filt=%qsysfunc(KTRANSLATE(%qktrim(&filt),", "," "));
15334 +        %let filt= %superq(filt);
15335 +        %let filt=%qsysfunc(TRANSTRN(&filt, %str(%')%qkupcase(%sysfunc(sasmsg(sashelp.tmine, rpt_text_blank_value, NOQUOTE)))%str(%'), ''));
15336 +        /* need to account for both Chinese languages */
15337 +        %let chineseStr = %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zho_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zht_value,
15338 + NOQUOTE))));
15339 +        %let filt=%qsysfunc(TRANSTRN(&filt, %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))), &chineseStr));
15341 +        filename temp catalog 'sashelp.emtxtext.tm_filter_languages.source';
15342 +        %include temp;
15344 +        %tm_filter_languages(indata=&EM_IMPORT_DATA, outdata=_trainview, languages=%nrbquote(&filt), report_role=TRAIN);
15346 +        proc sql noprint;
15347 +            select count(*) into :doccnt from _trainview;
15348 +        quit;
15350 +        %if &doccnt = 0 %then %do;
15351 +            %let emexceptionstring=EMTOOL.FILTER_DATA_ZERO;
15352 +            %goto end_parse_train;
15353 +        %end;
15354 +    %end;
15356 +    /* prepare training dataset for processing */
15357 +    data &EM_EXPORT_TRAIN.(compress=yes);
15358 +        set _trainview;
15360 +        _document_ = _n_;
15361 +        label _document_="%sysfunc(sasmsg(sashelp.tmine, rpt_text_document_vlabel, NOQUOTE))";
15362 +    run;
15364 +   /* set metadata on &EM_EXPORT_TRAIN to give _document_ a role of id and
15365 +      measurement level of nominal
15366 +    */
15367 +   %em_metachange(name=_document_, role=ID, level=NOMINAL);
15369 +   /* Write the multiword XML out */
15370 +   %tmwritemulti(multids=&EM_USER_MULTIDS,
15371 +                 stopds=&EM_USER_STOPLIST,
15372 +                 startds=&EM_USER_STARTLIST,
15373 +                 synds=&EM_USER_SYNONYMDS,
15374 +                 multi=&EM_USER_MULTIWORD,
15375 +                 multidsout= &EM_LIB..&EM_NODEID._multiall);
15376 +%let default_entity=;
15377 +   /* The main parsing call for the docs */
15378 +   %tm_parse(inds=&EM_EXPORT_TRAIN,
15379 +             outds=&em_user_tmout,
15380 +             keyds=&EM_USER_TERMS,
15381 +             config=&EM_USER_TMCONFIG,
15382 +             multisyn=&EM_USER_MULTIWORD,
15383 +             var=&TM_PARSEVAR,
15384 +             stemming=&EM_PROPERTY_BSTEMS,
15385 +             filevar=&tm_filteredvar,
15386 +             stoplist=&EM_USER_stopList,
15387 +             startlist=&EM_USER_startList,
15388 +             delimit=&EM_PROPERTY_DELIMIT,
15389 +             tagging=&EM_PROPERTY_BPARTOFSPEECH,
15390 +             language=&EM_PROPERTY_LANGUAGE,
15391 +             ng=&EM_PROPERTY_NOUNGROUPS,
15392 +             TGConcepts=%superq(EM_PROPERTY_TGConcepts),
15393 +             TGCategories=&EM_PROPERTY_TGCategories,
15394 +             indexDir=&EM_NODEDIR.&EM_DSEP.,
15395 +             entities=&EM_PROPERTY_BPATTERNS,
15396 +             posignore=&EM_PROPERTY_IGNOREPOS,
15397 +             entignore=&EM_PROPERTY_IGNOREENTITIES,
15398 +             attribignore=&EM_PROPERTY_IGNOREATTRIB,
15399 +             filterds=,
15400 +             filterstatus=,
15401 +             synDS=&EM_USER_SYNONYMDS,
15402 +             outpos=&EM_USER_TMOUTPOS);
15405 +   %if %superq(syshptmine) ne  %then %do;
15406 +      %let EMEXCEPTIONSTRING = EMTOOL.HPTMINE,%superq(syshptmine);
15407 +      %let syscc=0;
15408 +      %goto end_parse_train;
15409 +   %end;
15411 +   %else  %if %superq(sysdocparse) ne  %then %do;
15412 +      %let EMEXCEPTIONSTRING = EMTOOL.DOCPARSE,%superq(sysdocparse);
15413 +      %let syscc=0;
15414 +      %goto end_parse_train;
15415 +   %end;
15418 +    /* add rolestring and attrstring labels for  roles and strings to data set*/
15419 +    proc sql;
15422 +       create table &EM_USER_TERMS as
15423 +         select
15424 +            a.key label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_key_vlabel,NOQUOTE))",
15425 +            a.term label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_term_vlabel,NOQUOTE))",
15426 +            a.role,
15427 +            case a.role
15428 +               when 'Abbr'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posabbr_value,   NOQUOTE))"
15429 +               when 'Adj'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadj_value,   NOQUOTE))"
15430 +               when 'Adv'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadv_value,   NOQUOTE))"
15431 +               when 'Aux'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaux_value,   NOQUOTE))"
15432 +               when 'Conj'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posconj_value,   NOQUOTE))"
15433 +               when 'Det'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdet_value,   NOQUOTE))"
15434 +               when 'Interj'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinterj_value,   NOQUOTE))"
15435 +               when 'Noun'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoun_value,   NOQUOTE))"
15436 +               when 'Num'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnum_value,   NOQUOTE))"
15437 +               when 'Part'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospart_value,   NOQUOTE))"
15438 +               when 'Pref'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospref_value,   NOQUOTE))"
15439 +               when 'Prep'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprep_value,   NOQUOTE))"
15440 +               when 'Pron'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospron_value,   NOQUOTE))"
15441 +               when 'Prop'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprop_value,   NOQUOTE))"
15442 +               when 'Punct'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospunct_value,   NOQUOTE))"
15443 +               when 'Verb'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverb_value,   NOQUOTE))"
15444 +               when 'VerbAdj'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverbadj_value,   NOQUOTE))"
15445 +               when 'PERSON'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posperson_value,   NOQUOTE))"
15446 +               when 'ORGANIZATION'  then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posorganizationerson_value, NOQUOTE))"
15447 +               when 'LOCATION'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poslocation_value, NOQUOTE))"
15448 +               when 'COMPANY'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscompany_value,  NOQUOTE))"
15449 +               when 'TITLE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postitle_value,    NOQUOTE))"
15450 +               when 'PHONE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posphone_value,    NOQUOTE))"
15451 +               when 'DATE'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdate_value,     NOQUOTE))"
15452 +               when 'TIME'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postime_value,     NOQUOTE))"
15453 +               when 'INTERNET'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinternet_value, NOQUOTE))"
15454 +               when 'MEASURE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posmeasure_value,  NOQUOTE))"
15455 +               when 'NOUN_GROUP'    then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoungroup_value,  NOQUOTE))"
15456 +               when 'SSN'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posssn_value,        NOQUOTE))"
15457 +               when 'CURRENCY'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscurrency_value,   NOQUOTE))"
15458 +               when 'PERCENT'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospercent_value,    NOQUOTE))"
15459 +               when 'TIME_PERIOD'   then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postimeperiod_value, NOQUOTE))"
15460 +               when 'PROP_MISC'     then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospropmisc_value,   NOQUOTE))"
15461 +               when 'VEHICLE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posvehicle_value,    NOQUOTE))"
15462 +               when 'ADDRESS'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaddress_value,    NOQUOTE))"
15463 +               else              a.role
15464 +          end as rolestring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_role_vlabel,NOQUOTE))",
15465 +          a.attribute,
15466 +          case a.attribute
15467 +              when 'Alpha'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attralpha_value,   NOQUOTE))"
15468 +              when 'Mixed'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrmixed_value,   NOQUOTE))"
15469 +              when 'Num'           then    "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrnum_value,   NOQUOTE))"
15470 +              when 'Entity'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrentity_value,   NOQUOTE))"
15471 +               else             a.ATTRIBUTE
15472 +          end as attrstring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_attribute_vlabel,NOQUOTE))",
15473 +          /*No weight var at this point*/
15474 +           /*a.weight label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_weight_vlabel,NOQUOTE))" format=5.3,*/
15475 +           a.freq label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_freq_vlabel,NOQUOTE))",
15476 +           a.numdocs label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_numdocs_vlabel,NOQUOTE))",
15477 +           a.keep label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_keep_vlabel,NOQUOTE))",
15478 +           a._ispar label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_isparent_vlabel,NOQUOTE))",
15479 +           a.parent label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel,NOQUOTE))",
15480 +           a.parent_id label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parentid_vlabel,NOQUOTE))"
15481 +         from &EM_USER_TERMS  a;
15482 +    quit;
15483 +   data &EM_USER_tmconfig;
15484 +      length multiencoding $24 NG $3
15485 +         %if %superq(EM_PROPERTY_TGConcepts) ne %then %do;
15486 +         litilist $%eval(%klength(%superq(EM_PROPERTY_TGConcepts)) + 2 +
15487 +                       %klength(%superq(default_entity)))
15488 +            %end;
15489 +            ;
15490 +      set &EM_USER_tmconfig;
15492 +            parseVar = lowcase("&tm_parseVar");
15493 +            displayVar = lowcase("&tm_displayVar");
15494 +            indexpath = "&EM_NODEDIR.&EM_DSEP.";
15495 +            multiencoding="utf-8";
15496 +            %if %nrbquote(&filt) ne %then filterLangs="%nrbquote(&filt)"; %else filterLangs="";;
15498 +            /* Need to correct differences between hptmine and tgparse values for tmconfig
15499 +               table [cox] 11/24/2014  These may need to be changed again if we use
15500 +               proc hptmscore for scoring. */
15502 +            if NG="Y" then NG="STD"; else if NG="N" then NG="OFF";
15503 +            if entities="STD" then entities="Y";
15504 +            language=lowcase(language);
15505 +            %if %superq(EM_PROPERTY_TGConcepts) ne
15506 +               and ((&EM_PROPERTY_BPATTERNS eq CUSTOM and %upcase(&EM_PROPERTY_NOUNGROUPS) eq Y)
15507 +                    or &EM_PROPERTY_BPATTERNS eq ALL) %then %do;
15508 +                    litilist="%superq(EM_PROPERTY_TGConcepts)"||';'|| "%superq(default_entity)";
15509 +                    %end;
15510 +            %else %if &EM_PROPERTY_BPATTERNS eq CUSTOM %then %do;
15511 +               entities="Y";
15512 +               litilist="%superq(EM_PROPERTY_TGConcepts)";
15513 +               %end;
15515 +            run;
15518 +   /* Sort our terms data set and create an index for it
15519 +      Sort by term */
15520 +   proc sort data=&em_user_terms;
15521 +      %if %sysfunc(strip(&EM_PROPERTY_IGNOREPOS)) ne %then %do;
15522 +         by term role;
15523 +      %end;
15524 +      %else %do;
15525 +         by term;
15526 +      %end;
15527 +   run;
15529 +   /* Save the dataset information out to EMINFO */
15530 +   data &EM_DATA_EMINFO;
15531 +      length TARGET KEY $32 DATA $43;
15533 +      key="LastTMNode";
15534 +      data="&EM_NODEID";
15535 +      output;
15537 +      key="LastTMNodeType";
15538 +      data="TextParsing";
15539 +      output;
15541 +      key="LastTextParsing";
15542 +      data="&EM_NODEID";
15543 +      output;
15544 +    %if &filt ne %then %do;
15545 +          key="PRESCORECODE";
15546 +          data="&EM_NODEID";
15547 +          output;
15548 +    %end;
15549 +   run;
15553 +%end_parse_train:
15554 +   filename temp;
15555 +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
15556 +   %if &tm_debug =0 %then %do;
15557 +      proc sql noprint;
15558 +         drop table internal_synds;
15559 +         drop table tm_languages;
15560 +         drop view _trainview;
15561 +      quit;
15562 +   %end;
15565 +%mend train;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_ACTIONS.SOURCE.
15566 +%macro openTable1();
15567 +/* initiate all possible tables if not already there*/
15569 +   %em_getname(key=synonymDS, type=data);
15570 +   %em_getname(key=multiDS, type=data);
15571 +   %em_getname(key=stopList, type=data);
15572 +   %em_getname(key=startList, type=data);
15574 +   /* set a macro for conditional Syn actions */
15575 +   %global tm_parse_action_syn;
15576 +   %let tm_parse_action_syn=1;
15578 +   %if ^%sysfunc(exist(&em_user_stoplist)) %then %do;
15579 +      proc sql noprint;
15580 +         create table &em_user_stopList
15581 +         (term char(256)
15582 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
15583 +          role char(256)
15584 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
15585 +             );
15586 +      quit;
15587 +      data &em_user_stoplist;
15588 +         format term $256.;
15589 +         set &em_user_stoplist &em_property_stoplist;
15590 +      run;
15591 +   %end;
15593 +   %if ^%sysfunc(exist(&em_user_synonymds)) %then %do;
15594 +      proc sql noprint;
15595 +         create table &em_user_synonymDS
15596 +         (term char(256)
15597 +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_term_vlabel, NOQUOTE))",
15598 +          termrole char(256)
15599 +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_termrole_vlabel, NOQUOTE))",
15600 +          parent char(256)
15601 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parent_vlabel, NOQUOTE))",
15602 +          parentrole char(256)
15603 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parentrole_vlabel, NOQUOTE))"
15604 +             );
15605 +      quit;
15606 +      data &em_user_synonymds;
15607 +         set &em_user_synonymDS &em_property_synonymds;
15608 +      run;
15609 +   %end;
15611 +   %if ^%sysfunc(exist(&em_user_multids)) %then %do;
15612 +      proc sql noprint;
15613 +         create table &em_user_multiDS
15614 +         (term char(256)
15615 +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_TERM_VLABEL, NOQUOTE))",
15616 +          role char(256)
15617 +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_ROLE_VLABEL, NOQUOTE))"
15618 +             );
15619 +       quit;
15621 +      data &em_user_multids;
15622 +         set &em_user_multids &em_property_multids;
15623 +      run;
15624 +   %end;
15626 +   %if ^%sysfunc(exist(&em_user_startList)) %then %do;
15627 +     proc sql noprint;
15628 +      create table &EM_USER_startList
15629 +         (term char(256)
15630 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
15631 +          role char(256)
15632 +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
15633 +             );
15634 +    quit;
15635 +    data &em_user_startlist;
15636 +         set &em_user_startlist &em_property_startlist;
15637 +      run;
15639 +   %end;
15641 +%mend openTable1;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.GETLANGUAGES.SOURCE.
15643 +data work.raw_tm_languages work.all_languages;
15644 +   length language $20;
15645 +   input language $1-14 displaytext $15-69 prodnum;
15646 +
15647 +   output work.all_languages;
15648 +   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.))))
15649 +        then output work.raw_tm_languages;
15650 +   drop prodnum;
15651 +
15652 +   datalines;

NOTE: The data set WORK.RAW_TM_LANGUAGES has 2 observations and 2 variables.
NOTE: The data set WORK.ALL_LANGUAGES has 28 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

15681 +;
15682 +run;
15683 +
15684 +
15685 +
15686 +
15687 +proc sql noprint;
15688 +   create table work.tm_languages as
15689 +      select distinct(language), displaytext
15690 +      from work.raw_tm_languages;
NOTE: Table WORK.TM_LANGUAGES created, with 2 rows and 2 columns.

15691 +   create table work.all_tm_languages as
15692 +      select distinct(language), displaytext
15693 +      from work.all_languages;
NOTE: Table WORK.ALL_TM_LANGUAGES created, with 27 rows and 2 columns.

15694 +   drop table work.raw_tm_languages;
NOTE: Table WORK.RAW_TM_LANGUAGES has been dropped.
15695 +   drop table work.all_languages;
NOTE: Table WORK.ALL_LANGUAGES has been dropped.
15696 +quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

15697 +
NOTE: %INCLUDE (level 1) ending.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_PARSE.SOURCE.
15698 +/* ****************************************************************
15699 + * Name:    tmparse (macro)
15700 + *
15701 + * Support: Jim Cox
15702 + *
15703 + * Usage: %tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,keyvar=_document_,
15704 + *                var=,docidvar=, filevar=,config=,
15705 + *                stemming=Y,tagging=Y,ng=Y,entities=NONE,
15706 + *                stoplist=, startlist=, inkey=,doc_id=,
15707 + *                posignore=, entignore=,entkeep=, attribignore=,
15708 + *                reducef=1,termwgt=,cellwgt=,
15709 + *                language=english, multisyn=, nopos=, TGConcepts=,
15710 + *                TGCategories=, indexDir=,out_parent=,
15711 + *                delimit=Formal,outpos=,filterds=,filterstatus=drop);
15712 + * Purpose: To run Text parsing
15713 + *
15714 + * Parms:
15715 + * inds=<dataset> Specifies the input document dataset. This ds has a variable containing
15716 + *      the actual text or a path to the actual text.
15717 + * outds=<dataset> The output OUT table containing variables _TERMNUM_,
15718 + *      _DOCUMENT_,ENTRY. This represents the output term-by- document
15719 + *      frequency matrix.
15720 + * keyds=<dataset> Species the output terms table of terms with their
15721 + *      assoiciated KEY(numeric id) and summary statistics
15722 + * synds=<dataset> An input data set for applying user defined synonyms.
15723 + *      The dataset should contain variables TERM and PARENT and
15724 + *      optionally TERMROLE and PARENTROLE. All occurrences in the text of
15725 + *      matching strings for the term will be assigned the associated parent.
15726 + * keyvar=_document_
15727 + * var=<variable name> Specifies the variable on the inds dataset
15728 + *      that contains the text to be parsed.
15729 + * docidvar=<variable name> This specifies an integer valued variable
15730 + *      that must be on the inds document table. Rather than indexing documents
15731 + *      from 1 to n, this optional setting allow you to control what
15732 + *      id values for documents are used on the OUTds table
15733 + * filevar= Instead of var=, this speicifies the variable on the inds dataset
15734 + *      that contains a path to the plain text documents to be parsed.
15735 + * config=<dataset> An output and an input dataset containing the settings specfied
15736 + *      on this run. If the config exists when specified, the settings
15737 + *      found in the config file will override settings on this macro.
15738 + * stemming=<Y or N> Determines if terms will be stemmed to their root forms.
15739 + * tagging=<Y or N> Determines if the parsed terms will be assigned a
15740 + *      part-of-speech tag.
15741 + * ng=<Y or N> Determines if noun groups will be found as terms.
15742 + * entities=<NONE,DEFAULT, CUSTOM, ALL> Controls if entities are
15743 + *      found during the parse
15744 + *      NONE - do not find entities
15745 + *      DEFAULT - Identify the standard entities
15746 + *      CUSTOM - Use a customizeed file to extract user-specific
15747 + *               entities
15748 + *      ALL - identify the standard entities and extract user-specific entities.
15749 + * stoplist= <dataset> Provide an input list of terms to stop. Variables
15750 + *       are TERM and optionally TERMROLE
15751 + * startlist=<dataset> Provide an input list of terms to keep (all others
15752 + *       will be stopped). Variables are TERM and optionally TERMROLE
15753 + * inkey= <dataset> This option is there to support iterative parsing
15754 + *      It controls the numbering of terms.  The data set inkey comes
15755 + *      from a previous parse and proc tgparse uses the term keys found
15756 + *      there so that identical terms will receive the same key as a previous
15757 + *      parse.
15758 + * doc_id=<nonneg integer>  This also supports iterative parsing and tells
15759 + *      tgparse to start numbering docs at Doc_id rather than with a 1.
15760 + * posignore="POS1" "POS2" .... Allows user to specify a list of part-of-
15761 + *      speech tags. Any terms with these tags will be removed.
15762 + *      For example  posignore="DET" "PREP"
15763 + * entignore="ENT1" "ENT2"... Allows user to specify a list of entity
15764 + *      types. Any terms with these tags will be removed.
15765 + *      For example  entignore="COMPANY" "PRODUCT"
15766 + * entkeep="ENT1" "ENT2" ... Allows user to specify a list of entity
15767 + *      types. Any terms with these tags will be kept and all others
15768 + *       remove. *      For example  entkeep="COMPANY" "PRODUCT"
15769 + * attribignore="ATTRIB1" "ATTRIB2"...Allows user to specify a list of
15770 + *      attributes. Any terms with these attribues will be removed.
15771 + *      For example  posignore="NUM" "PUNCT"
15772 + * reducef=<Positive Integer> Setting lets you specify when to dynamically
15773 + *      stop terms from the analysis. They must appear in at least
15774 + *      reducef documents in order to be kept.
15775 + * termwgt=<NONE, ENTROPY, oR MI> Specify the term weight for each term
15776 + * cellwgt=<NONE or LOG> Specify the cell weight for terms
15777 + * language=<english> Specify the langugage of the text you are parsing
15778 + * multisyn=<filename> Specify the path to a custom multiword term file.
15779 + * nopos=
15780 + * TGConcepts=<filename> Specify the location of custom concept definition
15781 + *       file
15782 + * TGCategories= IGNORED CURRENTLY
15783 + * indexDir= The output location of the search index that can be built with the
15784 + *    input document data.
15785 + * out_parent= An output term-document table that has all children's
15786 + *    (from stemming and synonyms )frequencies
15787 + *    replaced and attributed to their parents. This is the representative form
15788 + *    for the parse collection
15789 + * delimit=Formal IGNORED CURRENTLY
15790 + * outpos=<dataset> An output dataset containing the offset information of
15791 + *    every term in the collection.
15792 + * filterds=<dataset> The name of the dataset of terms used for filtering.
15793 + *        This data set can be used to set terms to keep or drop based
15794 + *        on the filterstatus setting.
15795 + * filterstatus=drop
15796 + * langchk=yes
15797 + *
15798 + * Returns:
15799 + *
15800 + * History:
15801 + * 01Dec05 Initial Coding [cox]
15802 + *
15803 + *
15804 + * Notes:
15805 + * Last Modified By:
15806 + * Last Modified On: Thu Mar 26 13:24:22 2015
15807 + * End
15808 + * ************************************************************** */
15810 +%macro tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,docidvar=_document_,
15811 +                 var=, filevar=, config=,
15812 +                 stemming=Y,tagging=Y,ng=Y,entities=NONE,
15813 +                 stoplist=, startlist=, inkey=,doc_id=,reducef=1,termwgt=,cellwgt=,
15814 +                 posignore=, entignore=,entkeep=, attribignore=,
15815 +                 language=english, multisyn=, nopos=, TGConcepts=,
15816 +                 TGCategories=, indexDir=,out_parent=, langchk=yes,
15817 +                 delimit=Formal,outpos=,filterds=,filterstatus=drop);
15819 +%global default_entity;
15820 +%let language=%lowcase(&language);
15821 +%let attribtest=%upcase(&attribignore);
15822 +%let filterstatus=%upcase(&filterstatus);
15823 +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
15824 +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
15825 +%if &tm_hptmineBuildIndex ne 1 %then %let tm_hptmineBuildIndex=0;
15828 +/* Now do tests to determine which proc we will run */
15829 +%if &tm_hptmineBuildIndex=0 and %nrbquote(&indexDir) ne %then %let parse_proc=tgparse;
15831 +/* if asked to select/drop entities or pos also use tgparse
15832 +    [cox] No longer true so removing condition 9/4/2014 */
15833 +/* %else %if &posignore ne or &entignore ne or &entkeep ne
15834 +    %then %let parse_proc=tgparse;
15835 +*/
15837 +/* otherwise, if language not English or German, use tgparse */
15838 +%else %if &language ne english and &language ne german and
15839 +   &language ne chinese and &language ne spanish and
15840 +   &language ne italian and &language ne portuguese and
15841 +   &language ne dutch and &language ne korean and
15842 +   &language ne french and &language ne russian and
15843 +   &language ne finnish and &language ne turkish
15844 +   and &language ne japanese  and &langchk = yes
15845 + %then %let parse_proc=tgparse;
15847 +/* Otherwise, attribignore must contain NUM and PUNCT but not ABBR, ALPHA, or MIXED
15848 +  [cox] No longer true so removing condition 9/4/2014
15849 +  */
15850 +/*
15851 +%else %if %index(&attribtest, NUM) eq 0 or %index(&attribtest, PUNCT) eq 0 or
15852 +   %index(&attribtest, ABBR) ne 0 or %index(&attribtest, ALPHA) ne 0 or
15853 +   %index(&attribtest, MIXED) ne 0 %then %let parse_proc=tgparse;
15854 +*/
15856 +/* finally, must not be updating a previously generated key table */
15858 +%else %if &inkey ne %then %let parse_proc=tgparse;
15859 +   %else %let parse_proc=hptmine;
15861 +   /* delete the tmconfig file so we do not use another tmconfig from a previous node */
15862 +   %if &config ne %then %do;
15863 +      proc sql noprint;
15864 +         drop table &config;
15865 +      quit;
15866 +   %end;
15869 +   /* fix quote problems (replace single quote with double quotes) in posignore=,
15870 +      entignore=, attribignore= .  What about entkeep= (cox)? */
15871 +   data _null_;
15872 +      %if %ktrim(&posignore) ne %then %do;
15873 +         posignore = "&posignore";
15874 +         posignore = transtrn(posignore, "'", '"');
15875 +         call symput("posignore", posignore);
15876 +      %end;
15877 +      %if %ktrim(&entignore) ne %then %do;
15878 +         entignore = "&entignore";
15879 +         entignore = transtrn(entignore, "'", '"');
15880 +         call symput("entignore", entignore);
15881 +      %end;
15882 +      %if %ktrim(&attribignore) ne %then %do;
15883 +         attribignore = "&attribignore";
15884 +         attribignore = transtrn(attribignore, "'", '"');
15885 +         call symput("attribignore", attribignore);
15886 +      %end;
15887 +   run;
15889 +   %let stoplist_count = 0;
15890 +   %let startlist_count = 0;
15891 +   %let synds_count = 0;
15892 +   proc sql noprint;
15893 +      %if "&stoplist" ne "" %then %do;
15894 +         select count(*) into :stoplist_count
15895 +         from &stoplist;
15896 +      %end;
15897 +      %if "&startlist" ne "" %then %do;
15898 +         select count(*) into :startlist_count
15899 +         from &startlist;
15900 +      %end;
15901 +      %if "&synds" ne "" %then %do;
15902 +         select count(*) into :synds_count
15903 +         from &synds;
15904 +      %end;
15905 +   quit;
15907 +   /* control behavior of custom entities */
15908 +   %if &parse_proc eq tgparse %then %let ent_true=yes; %else %let ent_true=std;
15909 +   %if &parse_proc eq tgparse %then %let ent_false=no; %else %let ent_false=none;
15910 +   %let entity_info = ;
15911 +   %if &entities eq NONE %then %do;
15912 +      %let entity_info = entities=&ent_false ;
15913 +      %let entignore = ; %let entkeep=;
15914 +   %end;
15915 +   %else %if &entities eq DEFAULT %then %do;
15916 +      %let entity_info = entities=&ent_true ;
15917 +   %end;
15918 +   /* Otherwise entities are CUSTOM or ALL */
15919 +   %else %do;
15920 +      /* Need to set up default entities if NG on or entities set to ALL */
15921 +      %if &entities eq ALL or %upcase(&ng) eq Y %then %do;
15922 +      %let default_entity = %sysfunc(pathname(SASROOT))&EM_DSEP ;
15924 +      %if "&EM_DSEP" eq "/" %then %do;
15925 +         /* unix */
15926 +         %let default_entity = &default_entity.misc&EM_DSEP.tktg&EM_DSEP. ;
15927 +         %end;
15928 +      %else %if "&EM_DSEP" eq "\" %then %do;
15929 +         /* windows */
15930 +         %let default_entity = &default_entity.tktg&EM_DSEP.sasmisc&EM_DSEP. ;
15931 +         %end;
15932 +      %let entity_language = %lowcase(&language);
15934 +      %if "&entity_language" eq "arabic" %then %do;
15935 +         %let default_entity = &default_entity.ar-ne.li ;
15936 +         %end;
15937 +      %else %if "&entity_language" eq "german" %then %do;
15938 +         %let default_entity = &default_entity.de-ne.li ;
15939 +         %end;
15940 +      %else %if "&entity_language" eq "english" %then %do;
15941 +         %let default_entity = &default_entity.en-ne.li ;
15942 +         %end;
15943 +      %else %if "&entity_language" eq "spanish" %then %do;
15944 +         %let default_entity = &default_entity.es-ne.li ;
15945 +         %end;
15946 +      %else %if "&entity_language" eq "french" %then %do;
15947 +         %let default_entity = &default_entity.fr-ne.li ;
15948 +         %end;
15949 +      %else %if "&entity_language" eq "italian" %then %do;
15950 +         %let default_entity = &default_entity.it-ne.li ;
15951 +         %end;
15952 +      %else %if "&entity_language" eq "japanese" %then %do;
15953 +         %let default_entity = &default_entity.jp-ne.li ;
15954 +         %end;
15955 +      %else %if "&entity_language" eq "korean" %then %do;
15956 +         %let default_entity = &default_entity.kr-ne.li ;
15957 +         %end;
15958 +      %else %if "&entity_language" eq "dutch" %then %do;
15959 +         %let default_entity = &default_entity.nl-ne.li ;
15960 +         %end;
15961 +      %else %if "&entity_language" eq "polish" %then %do;
15962 +         %let default_entity = &default_entity.pl-ne.li ;
15963 +         %end;
15964 +      %else %if "&entity_language" eq "portuguese" %then %do;
15965 +         %let default_entity = &default_entity.pt-ne.li ;
15966 +         %end;
15967 +      %else %if "&entity_language" eq "chinese" %then %do;
15968 +         %let default_entity = &default_entity.zh-ne.li ;
15969 +         %end;
15970 +      %else %if "&entity_language" eq "russian" %then %do;
15971 +         %let default_entity = &default_entity.ru-ne.li ;
15972 +         %end;
15973 +      %else %if "&entity_language" eq "turkish" %then %do;
15974 +         %let default_entity = &default_entity.tr-ne.li ;
15975 +         %end;
15976 +      %else %if "&entity_language" eq "thai" %then %do;
15977 +         %let default_entity = &default_entity.th-ne.li ;
15978 +         %end;
15979 +      %else %if "&entity_language" eq "vietnamese" %then %do;
15980 +         %let default_entity = &default_entity.vi-ne.li ;
15981 +         %end;
15982 +      %else %if "&entity_language" eq "norwegian" %then %do;
15983 +         %let default_entity = &default_entity.no-ne.li ;
15984 +         %end;
15985 +      %else %if "&entity_language" eq "danish" %then %do;
15986 +         %let default_entity = &default_entity.da-ne.li ;
15987 +         %end;
15988 +      %else %if "&entity_language" eq "greek" %then %do;
15989 +         %let default_entity = &default_entity.el-ne.li ;
15990 +         %end;
15991 +      %else %if "&entity_language" eq "romanian" %then %do;
15992 +         %let default_entity = &default_entity.ro-ne.li ;
15993 +         %end;
15994 +      %else %if "&entity_language" eq "hebrew" %then %do;
15995 +         %let default_entity = &default_entity.he-ne.li ;
15996 +         %end;
15997 +      %else %if "&entity_language" eq "czech" %then %do;
15998 +         %let default_entity = &default_entity.cs-ne.li ;
15999 +         %end;
16000 +      %else %if "&entity_language" eq "slovak" %then %do;
16001 +         %let default_entity = &default_entity.sk-ne.li ;
16002 +         %end;
16003 +      %else %if "&entity_language" eq "hungarian" %then %do;
16004 +         %let default_entity = &default_entity.hu-ne.li ;
16005 +         %end;
16006 +      %else %if "&entity_language" eq "indonesian" %then %do;
16007 +         %let default_entity = &default_entity.id-ne.li ;
16008 +         %end;
16009 +      %else %if "&entity_language" eq "finnish" %then %do;
16010 +         %let default_entity = &default_entity.fi-ne.li ;
16011 +         %end;
16012 +      %else %let default_entity=&ent_false;
16014 +         %end;
16016 +   %if &entities eq CUSTOM %then %do;
16017 +      %if %superq(TGConcepts) ne %then %do;
16018 +         %if &parse_proc eq tgparse %then %let ent_flag=&ent_true;
16019 +         %else %let ent_flag=&ent_false;
16020 +         %let entity_info = entities=&ent_flag litilist=("&TGConcepts") ;
16021 +      %end;
16022 +      %else %do;
16023 +         %let entity_info = entities=&ent_false ;
16024 +      %end;
16026 +      /* %let entignore = ; */
16027 +      %end;
16028 +   %else %if &entities eq ALL %then %do;
16030 +      %if %nrbquote(&TGConcepts) ne %then %do;
16031 +         %if &parse_proc eq tgparse %then
16032 +            %let entity_info= entities=&ent_true litilist=("&default_entity" "&TGConcepts") ;
16033 +         %else %let entity_info= entities=&ent_true litilist=("&TGConcepts") ;
16034 +         %end;
16035 +      %else %let entity_info= entities=&ent_true;
16038 +      %end;
16040 +%end;
16042 +   /* main docparse call */
16043 +%if &parse_proc eq tgparse %then %do;
16044 +      proc tgparse data=&inds key=&keyds out=&outds
16045 +         %if &filterds ne %then %do;
16046 +            %if %upcase(&filterstatus) eq DROP %then stop=&filterds;
16047 +            %else %if %upcase(&filterstatus) eq KEEP %then start=&filterds;
16048 +            %else %if %upcase(&filterstatus) eq IGNORE %then ignore=&filterds;
16049 +            %else %if %upcase(&filterstatus) eq RETAIN %then retain=&filterds;
16050 +            %end;
16051 +         %if &config ne %then config=&config;
16052 +         %if &nopos ne %then NOPOS;
16053 +         %if &synds_count ne 0 %then syn=&synds;
16054 +         %if "&multisyn" ne "" %then multiterm="&multisyn";
16055 +         %if %upcase(&stemming) eq Y %then stemming=yes ; %else stemming=no ;
16056 +         %if %upcase(&tagging) eq Y %then tagging=yes ; %else tagging=no ;
16057 +         &entity_info
16058 +         /* %if "%trim(%left(&TGCategories))" ne "" %then TGCategories=&TGCategories ; */
16059 +         %if "%nrbquote(&indexDir)" ne "" %then %do;
16060 +            buildindex=yes
16061 +            indexpath="%nrbquote(&indexDir)"
16062 +         %end;
16063 +         %if &stoplist_count ne 0  %then stop=&stoplist;
16064 +         %else %if &startlist_count ne 0  %then start=&startlist;
16065 +         %if %upcase(&ng) eq Y %then ng=std ;
16066 +         %else ng=off ;
16067 +         %if &filevar ne %then namedfile;
16068 +         %if %lowcase(&language) ne other %then language=%lowcase(&language);
16069 +         %else plugin="SAS";
16070 +         %if &outpos ne %then %do; outoffset=&outpos addsentence addparagraph %end;
16071 +         %if &inkey ne %then  inkey=&inkey;
16072 +         %if &doc_id ne %then doc_id=&doc_id;
16074 +         ;
16075 +      var %if &filevar ne %then &filevar; %else &var; ;
16076 +      %if %upcase(&docidvar) ne _DOCUMENT_ %then id &docidvar;;
16078 +      select &posignore "Newline" / drop;
16079 +      %if &attribignore ne %then select &attribignore / group="attributes" drop; ;
16080 +      %if &entkeep ne and &entignore =  %then %do;
16081 +          select &entkeep / group="entities" keep;
16082 +      %end;
16083 +      %else %do;
16084 +          %if &entignore ne %then select &entignore / group="entities" drop; ;
16085 +      %end;
16086 +      run;
16087 +%end;
16089 +%else %do;
16091 +proc hptmine data=&inds language=&language;
16092 +    var %if &filevar ne %then &filevar; %else &var; ;
16093 +   doc_id &docidvar;
16094 +   parse reducef=&reducef outterms=&keyds
16095 +      %if &filevar ne %then namedfile;
16097 +      %if &filterds ne %then %do;
16098 +          %if %upcase(&filterstatus) eq DROP or %upcase(&filterstatus) eq IGNORE
16099 +             %then stop=&filterds;
16100 +          %else %if %upcase(&filterstatus) eq KEEP or %upcase(&filterstatus) eq RETAIN
16101 +             %then start=&filterds;
16102 +          %if %upcase(&filterstatus) ne IGNORE and %upcase(&filterstatus) ne RETAIN
16103 +             %then showdroppedterms;
16104 +      %end;
16105 +      %else showdroppedterms;
16107 +      %if &termwgt ne %then termwgt=&termwgt;
16108 +      %if &cellwgt ne %then cellwgt=&cellwgt;
16109 +      %if %upcase(&stemming) ne Y %then nostemming;
16110 +      %if %upcase(&tagging) ne Y %then notagging;
16111 +      %if %upcase(&ng) ne Y %then nonoungroups;
16112 +   %if &stoplist_count ne 0  %then stop=&stoplist;
16113 +   %else %if &startlist_count ne 0  %then start=&startlist;
16114 +%if 0 %then %do;
16115 +%end;
16116 +      %if &synds_count ne 0 %then syn=&synds;
16117 +         &entity_info
16118 +      %if "&multisyn" ne "" %then multiterm="&multisyn";
16119 +      %if "%nrbquote(&indexDir)" ne "" %then %do;
16120 +            buildindex
16121 +            indexpath="%nrbquote(&indexDir)"
16122 +      %end;
16124 +      %if &outds ne %then outchild=&outds;
16125 +      %if &outpos ne %then outpos=&outpos;
16126 +      %if &config ne %then outconfig=&config;
16127 +      %if &out_parent ne %then outparent=&out_parent;
16129 +   ;
16130 +     %if &posignore ne %then select &posignore "Newline" / ignore; ;
16131 +        %if &attribignore eq %then %let attribignore="";
16132 +      select &attribignore / group="attributes" ignore;
16133 +      %if &entkeep ne and &entignore =  %then %do;
16134 +         select &entkeep / group="entities" keep; ;
16135 +      %end;
16136 +      %else %do;
16137 +          %if &entignore ne %then select &entignore / group="entities" ignore; ;
16138 +      %end;
16139 +      performance /* nthreads=1 */ details;
16140 +   run;
16141 +%if %symexist(syshptmine) %then %let sysdocparse=&syshptmine;
16142 +%else %let sysdocparse=;
16144 +/* Change term and outpos tables so that they correspond to tgparse variable names */
16147 +/* Change term and outpos tables so that they correspond to tgparse variable names */
16148 +proc sql noprint;
16149 +   create table &keyds as select *,_keep as keep from &keyds
16150 +      order by _keep desc,numdocs desc;
16151 +  %if &outpos ne %then %do;
16152 +     create table tempKey as select
16153 +        a.key as _termnum_,
16154 +        a.term,
16155 +        a.role
16156 +        from &keyds a
16157 +        where a._ispar ne '+';
16159 +     create table tempoutpos as select
16160 +        a.document as _document_,
16161 +        a.sentence as _sentence_,
16162 +        a._start_ as _offset_,
16163 +        a._end_ - a._start_+1 as _length_,
16164 +        b._termnum_
16165 +        from &outpos as a , tempKey as b
16166 +        where b.term=a.term and b.role=a.role;
16168 +     create table tempoutds as select
16169 +        a.*
16170 +        from &outds as a, tempkey as b
16171 +        where a._termnum_= b._termnum_;
16173 +      create table &outpos as select
16174 +        a._document_,
16175 +        a._sentence_,
16176 +        a._offset_,
16177 +        a. _length_,
16178 +        a._termnum_,
16179 +        b._count_
16180 +        from tempoutpos as a, tempoutds as b
16181 +        where a._termnum_=b._termnum_ and a._document_ =b._document_;
16183 +       drop table tempoutpos;
16184 +       drop table tempKey;
16185 +     %end;
16186 +     /* improve tmutil performance*/
16187 +     proc sort data=&outds;
16188 +       by _termnum_ _document_;
16189 +     run;
16190 +  quit;
16192 +%end;
16194 +%end_tmparse:
16196 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TMWRITEMULTI.SOURCE.
16197 +/* ****************************************************************
16198 + * Name:    tmwritemulti.sas (macro)
16199 + *
16200 + *
16201 + * Usage: %tmwritemulti(multids=, stopds=, startds=, synds=, multi=);
16202 + * Purpose: To write out the text file for the multiword dictionary.  This will
16203 + *  include multiword term in the data= file as well as
16204 + * Parameters
16205 + * multids   = data set with multiword terms and their roles
16206 + * stopds    = stop word list - look for multiword terms
16207 + * startds   = start word list - look for multiword terms
16208 + * synds     = data set with synonyms and their roles
16209 + * multi     = multiterm text file.
16210 + * End
16211 + * ************************************************************** */
16212 +
16213 +
16214 +%macro tmwritemulti(multids=, stopds=, startds=, synds=, multi=, multidsout=);
16215 +
16216 +   * create a multiword terms data set ;
16217 +   proc sql noprint;
16218 +      create table _multiterms_
16219 +         (term   char(256),
16220 +          role   char(256));
16221 +   quit;
16222 +
16223 +   %let synds_count = ;
16224 +   %let stopds_count = ;
16225 +   %let startds_count = ;
16226 +   %let multids_count = ;
16227 +   proc sql noprint;
16228 +      select count(*) into :synds_count
16229 +      from &synds;
16230 +
16231 +      select count(*) into :stopds_count
16232 +      from &stopds;
16233 +
16234 +      %if &startds ne %then
16235 +      select count(*) into :startds_count
16236 +      from &startds;
16237 +      %else %let startds_count = 0;;
16238 +
16239 +      select count(*) into :multids_count
16240 +      from &multids;
16241 +   quit;
16242 +
16243 +   * check the synonym ds for multiword terms ;
16244 +   %if &synds_count ne 0 %then %do;
16245 +      %find_multiword_terms(data_in=&synds, data_append=_multiterms_);
16246 +   %end;
16247 +
16248 +   * check the stopTerms ds for multiword terms ;
16249 +   %if &stopds_count ne 0 %then %do;
16250 +      %find_multiword_terms(data_in=&stopds, data_append=_multiterms_);
16251 +   %end;
16252 +
16253 +   * check the startTerms ds for multiword terms;
16254 +   %if &startds_count ne 0 %then %do;
16255 +      %find_multiword_terms(data_in=&startds, data_append=_multiterms_);
16256 +   %end;
16257 +
16258 +   * check the multids for multiword terms ;
16259 +   %if &multids_count ne 0 %then %do;
16260 +      data work.multids_temp;
16261 +         length term $256 role $256;
16262 +         set &multids;
16263 +         if role eq '' then role='Noun';
16264 +      run;
16265 +      proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
16266 +      run;
16267 +      proc sql noprint;
16268 +         drop table work.multids_temp;
16269 +      run;
16270 +   %end;
16271 +
16272 +   * add lower and upper case variations to the multi word terms ;
16273 +
16274 +   data _multiterms_;
16275 +      set _multiterms_;
16276 +      term = transtrn(term, ':', '\:');
16277 +
16278 +      * output exactly as is ;
16279 +      output;
16280 +      * output lower case versions ;
16281 +      term=lowcase(term);
16282 +      output;
16283 +      * output upper case versions ;
16284 +      term=upcase(term);
16285 +      output;
16286 +      * output uppercase first letter of each term, lower rest ;
16287 +      term = propcase(term);
16288 +      output;
16289 +   run;
16290 +
16291 +   * remove duplicate term entries ;
16292 +   proc sort data= _multiterms_ nodupkey;
16293 +      by term role;
16294 +   run;
16295 +
16296 +   filename _multout "&multi";
16297 +
16298 +   * write out all the multiword terms ;
16299 +   data &multidsout;
16300 +      set _multiterms_;
16301 +      file _multout encoding="utf-8";
16302 +      put term ':3:' role;
16303 +   run;
16304 +
16305 +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
16306 +   %if &tm_debug =0 %then %do;
16307 +      proc sql noprint;
16308 +         drop table work._multiterms_;
16309 +      quit;
16310 +   %end;
16311 +
16312 +%mend tmwritemulti;
16313 +
16314 +
16315 +/*
16316 +
16317 +%tmwritemulti(language="english", data=sashelp.engsynms);
16318 +
16319 +*/
16320 +
16321 +%macro find_multiword_terms(data_in=, data_append=);
16322 +
16323 +   data &data_in._temp (keep=term role);
16324 +      length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
16325 +
16326 +      set &data_in;
16327 +
16328 +      if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
16329 +         if childrole ne '' then category = childrole;
16330 +         if role ne '' then category = role;
16331 +
16332 +         if lowcase(category) eq category then category=propcase(category) ;
16333 +
16334 +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
16335 +         else if category eq 'NOUN_GROUP' then role = 'Noun';
16336 +         else if category eq '' then role='Noun';
16337 +         else role = 'Prop';
16338 +
16339 +         output;
16340 +      end;
16341 +
16342 +      if "&data_in"="&synds" and anypunct(term,1) > 0 then do;
16343 +         term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
16344 +         if role ne '' then category = role;
16345 +
16346 +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
16347 +         else if category eq 'NOUN_GROUP' then role = 'Noun';
16348 +         else if category eq '' then role='Noun';
16349 +         else role = 'Prop';
16350 +
16351 +         output;
16352 +      end;
16353 +
16354 +      if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
16355 +         term = parent;
16356 +         if parentrole ne '' then category = childrole;
16357 +
16358 +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
16359 +         else if category eq 'NOUN_GROUP' then role = 'Noun';
16360 +         else if category eq '' then role='Noun';
16361 +         else role = 'Prop';
16362 +         output;
16363 +      end;
16364 +   run;
16365 +
16366 +   proc append base=&data_append data=&data_in._temp force;
16367 +   run;
16368 +
16369 +   proc sql noprint;
16370 +      drop table &data_in._temp;
16371 +   quit;
16372 +%mend find_multiword_terms;
NOTE: %INCLUDE (level 1) ending.

NOTE: There were 1 observations read from the data set EMWS5.TEXTPARSING_VARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      


NOTE: The data set WORK.EM_USER_PROPERTY has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

*------------------------------------------------------------*
NOTE: Variable used for parsing is: Message
*------------------------------------------------------------*

NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

NOTE: Table WORK.INTERNAL_SYNDS created, with 1 rows and 4 columns.

NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: SQL view WORK._TRAINVIEW has been defined.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      


NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      


NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      


NOTE: There were 2694 observations read from the data set EMWS5.PART_TRAIN.
NOTE: There were 2694 observations read from the data set WORK._TRAINVIEW.
NOTE: The data set EMWS5.TEXTPARSING_TRAIN has 2694 observations and 9 variables.
NOTE: Compressing data set EMWS5.TEXTPARSING_TRAIN decreased size by 50.00 percent. 
      Compressed is 7 pages; un-compressed would require 14 pages.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
      


NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: Table WORK._MULTITERMS_ created, with 0 rows and 2 columns.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      


NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS_TEMP has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      


NOTE: Appending WORK.INTERNAL_SYNDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS_TEMP.
NOTE: 1 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

NOTE: Table WORK.INTERNAL_SYNDS_TEMP has been dropped.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      


NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: Variable parent is uninitialized.
NOTE: Variable parentrole is uninitialized.
NOTE: There were 507 observations read from the data set EMWS5.TEXTPARSING_STOPLIST.
NOTE: The data set EMWS5.TEXTPARSING_STOPLIST_TEMP has 0 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      


NOTE: Appending EMWS5.TEXTPARSING_STOPLIST_TEMP to WORK._MULTITERMS_.
NOTE: There were 0 observations read from the data set EMWS5.TEXTPARSING_STOPLIST_TEMP.
NOTE: 0 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

NOTE: Table EMWS5.TEXTPARSING_STOPLIST_TEMP has been dropped.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


NOTE: There were 384 observations read from the data set EMWS5.TEXTPARSING_MULTIDS.
NOTE: The data set WORK.MULTIDS_TEMP has 384 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


NOTE: Appending WORK.MULTIDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 384 observations read from the data set WORK.MULTIDS_TEMP.
NOTE: 384 observations added.
NOTE: The data set WORK._MULTITERMS_ has 385 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

NOTE: Table WORK.MULTIDS_TEMP has been dropped.
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      


NOTE: There were 385 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set WORK._MULTITERMS_ has 1540 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      


NOTE: There were 1540 observations read from the data set WORK._MULTITERMS_.
NOTE: 385 observations with duplicate key values were deleted.
NOTE: The data set WORK._MULTITERMS_ has 1155 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      


NOTE: The file _MULTOUT is:
      Filename=P:\DMBI_Project\Twitter_Insta_Content_Engineering\Workspaces\EMWS5\TextParsing\multiword.txt,
      RECFM=V,LRECL=131068,File Size (bytes)=0,
      Last Modified=06May2020:18:32:11,
      Create Time=06May2020:18:00:16

NOTE: 1155 records were written to the file _MULTOUT.
      The minimum record length was 10.
      The maximum record length was 29.
NOTE: There were 1155 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set EMWS5.TEXTPARSING_MULTIALL has 1155 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.01 seconds
      

NOTE: Table EMWS5.TEXTPARSING_TMCONFIG has been dropped.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      


NOTE: No SPARSEFORMAT option is specified. SPARSEFORMAT=COO will be run by default.
NOTE: Stemming will be used in parsing.
NOTE: Tagging will be used in parsing.
NOTE: Noun groups will be used in parsing.
NOTE: No TERMWGT option is specified. TERMWGT=ENTROPY will be run by default.
NOTE: No CELLWGT option is specified. CELLWGT=LOG will be run by default.
NOTE: The HPTMINE procedure is executing in single-machine mode.
WARNING:  41 documents are either empty or cannot be read.
NOTE: There were 2694 observations read from the data set EMWS5.TEXTPARSING_TRAIN.
NOTE: There were 507 observations read from the data set EMWS5.TEXTPARSING_STOPLIST.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set EMWS5.TEXTPARSING_TERMS has 9096 observations and 11 variables.
NOTE: The data set EMWS5.TEXTPARSING_TMOUT has 23360 observations and 3 variables.
NOTE: The data set EMWS5.TEXTPARSING_TMOUTPOS has 23849 observations and 8 variables.
NOTE: The data set EMWS5.TEXTPARSING_TMCONFIG has 1 observations and 18 variables.
NOTE: The PROCEDURE HPTMINE printed page 2.
NOTE: PROCEDURE HPTMINE used (Total process time):
      real time           5.00 seconds
      cpu time            5.76 seconds
      

WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTPARSING_TERMS created, with 9096 rows and 12 columns.

NOTE: Table WORK.TEMPKEY created, with 7740 rows and 3 columns.

NOTE: Table WORK.TEMPOUTPOS created, with 23849 rows and 5 columns.

NOTE: Table WORK.TEMPOUTDS created, with 23360 rows and 3 columns.

NOTE: Table EMWS5.TEXTPARSING_TMOUTPOS created, with 23849 rows and 6 columns.

NOTE: Table WORK.TEMPOUTPOS has been dropped.
NOTE: Table WORK.TEMPKEY has been dropped.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.28 seconds
      cpu time            0.09 seconds
      


NOTE: There were 23360 observations read from the data set EMWS5.TEXTPARSING_TMOUT.
NOTE: The data set EMWS5.TEXTPARSING_TMOUT has 23360 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.07 seconds
      cpu time            0.03 seconds
      

WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTPARSING_TERMS created, with 9096 rows and 12 columns.

NOTE: PROCEDURE SQL used (Total process time):
      real time           0.53 seconds
      cpu time            0.17 seconds
      


NOTE: There were 1 observations read from the data set EMWS5.TEXTPARSING_TMCONFIG.
NOTE: The data set EMWS5.TEXTPARSING_TMCONFIG has 1 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
      


NOTE: There were 9096 observations read from the data set EMWS5.TEXTPARSING_TERMS.
NOTE: The data set EMWS5.TEXTPARSING_TERMS has 9096 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.49 seconds
      cpu time            0.03 seconds
      


NOTE: Variable TARGET is uninitialized.
NOTE: The data set EMWS5.TEXTPARSING_EMINFO has 3 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
      

NOTE: Fileref TEMP has been deassigned.
16373  *------------------------------------------------------------*;
16374  * End TRAIN: TextParsing;
16375  *------------------------------------------------------------*;
16376  
16377  
16378  
16379  

16380  *------------------------------------------------------------*;
16381  * Close any missing semi colons;
16382  *------------------------------------------------------------*;
16383  ;
16384  ;
16385  ;
16386  ;
16387  quit;
16388  *------------------------------------------------------------*;
16389  * Close any unbalanced quotes;
16390  *------------------------------------------------------------*;
16391  /*; *"; *'; */
16392  ;
16393  run;
16394  quit;
16395  /* Reset EM Options */
16396  options formchar="|----|+|---+=|-/\<>*";
16397  options nocenter ls=256 ps=10000;
16398  goptions reset=all device=GIF NODISPLAY;

16399  proc sort data=WORK.EM_METACHANGE;
16400  by key uname;
16401  run;

NOTE: There were 1 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

16402  filename x "P:\DMBI_Project\Twitter_Insta_Content_Engineering\Workspaces\EMWS5\TextParsing\CDELTA_TRAIN.sas";
16403  data _null_;
16404  file x;
16405  put 'if upcase(NAME) = "_DOCUMENT_" then do;';
16406  put 'ROLE = "ID";';
16407  put 'LEVEL = "NOMINAL";';
16408  put 'end;';
16409  run;

NOTE: The file X is:
      Filename=P:\DMBI_Project\Twitter_Insta_Content_Engineering\Workspaces\EMWS5\TextParsing\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=06May2020:18:32:17,
      Create Time=06May2020:17:53:56

NOTE: 4 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 39.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
      

16410  filename x;
NOTE: Fileref X has been deassigned.

